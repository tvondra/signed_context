# signed_context (EXPERIMENTAL)

[![make installcheck](https://github.com/tvondra/signed_context/actions/workflows/ci.yml/badge.svg)](https://github.com/tvondra/signed_context/actions/workflows/ci.yml)
[![PGXN version](https://badge.fury.io/pg/signed_context.svg)](https://badge.fury.io/pg/signed_context)

An experimental extension implementing a context for Postgres, protected 
by public-key signatures. This is meant to be useful for use casesthat
require a trusted context the users can't manipulate.


## Motivation

Use cases like RLS require trustes session to store values referenced
in the policies. The canonical RLS examples rely on Postgres roles to
do this, but that has various issues. Each user requires a separate
role, and managing many roles can be challenging.

It also complicates connection pooling, because connections are tied to
roles. The pooler can either operate one pool per role, but with many
roles that goes directly against the idea of connection pooling. Or it
can use a common role and use `SET ROLE` to set the "correct" role for
the user, and then `RESET ROLE` when the connection is returned.

This however is a security hole, because there's nothing preventing the
regular user from issuing `RESET ROLE` + `SET ROLE` to arbitrary role.
The community [discusses](https://www.postgresql.org/message-id/CACA6kxh4MfRCHuY%2BuC2ZvXRQUP63LqumNtxtLsDF-mJswAJR5w%40mail.gmail.com)
ways to address this, possibly by implementing role sandboxing. But
even if some form of "role sandboxing" (or something else protecting
the `SET ROLE` approach) gets committed, the issues with tying this RLS
policies to regular roles will remain.

This extension is an attempt to provide a different type of a trusted
context, unrelated from roles. It's based on public-key signatures
(using the [libsodium](https://doc.libsodium.org/) library).

Users are assigned contexts (imagine a string encoding a small number of
key/value pairs), encoding the important values needed by RLS policies.
This might include fields `TENANT_ID`, and `COUNTRY`, for example

```
TENANT_ID:213234:COUNTRY:US
```

The context is then signed by a secret key, and the signature is added
to the beginning of the context (in base64 encoding)

```
aXG0jW7...FmJVrfoyDA==:TENANT_ID:213234:COUNTRY:US
```

The secret key is known only to privileged users, and may not be known
to the database at all (the signing can happen anywhere). The database
is aware only of the associated public key, and uses it to verify the
context when it's being "installed" for a session.

To set the context, the user sets it to a `GUC` defined by the extension

```sql
SET signed_context.context = 'aXG0jW7...FmJVrfoyDA==:TENANT_ID:213234:COUNTRY:US';
```

At this point the database verifies the signature (using the public key)
and accepts it only if the signature matches. If the verification fails,
the `SET` fails with an error, and the context remains empty.

If the verification succeeds, the context is parsed into key/value pairs
and the session can use the function `signed_context_get()` to lookup
value, for example from the RLS policies.

```sql
SELECT signed_contect_get('TENANT_ID');
```

When the user returns to the connection pool, the connection pool resets
it by `RESET ALL`, which discards the context too. This makes it ready
for a new user, possibly with a different `TENANT_ID`.


## GUCs

The extension defines two configuration parameters for setting up the
context - the key for signature verification, and the context itself.

### `security_context.key`

This is the public key, generated by
[`crypto_sign_keypair`](https://doc.libsodium.org/public-key_cryptography/public-key_signatures),
in base64-encoding. The key pair can be generated anywhere (even outside
the database) or using the function `signed_context_generate_keys()`.

The GUC is defined in the "superuser" (`PGC_SUSET`)
[context](https://www.postgresql.org/docs/current/view-pg-settings.html),
which means only a superuser can set it. There are several practical
ways to define this parameter:

* `postgresql.conf` - The simplest option. There's a single key for the
  whole instance, i.e. all databases/users will use the same key.

* `ALTER DATABASE` / `ALTER ROLE` - Allows setting keys for individual
  databases and/or roles. Useful for instances serving multiple apps.

* startup packet / SQL - Allows per-connection / per-session values, if
  the connecting role is a superuser. But it also has the weakness
  described earlier, with the user being able to execute `RESET ROLE`.

* security-definer function - A variant of the SQL option, but the key
  is installed in a controlled way (i.e. not determined by the user).

  
Using superuser roles breaks the signing scheme (more in the following
sections). This rules out the "startup packet / SQL" option, with the
exception of testing.


### `security_context.context`

An option storing the context (a set of key/value pairs). The user can
simply do

```sql
SET signed_context.context = '....';
```

The system verifies the signature (using the `signed_context.key` key),
parses the value, etc. If everything goes well, the context is set to
the signed payload.

The context may be reset using `RESET` when not needed. The connection
pool should do this automatically before reusing the connection, by
executing `RESET ALL`.


## Threat model

The threat model depends on what components are involved in handling
database connection, and whether those components are trusted or not.
To discuss the threat model we need to define a couple basic pieces:

* connection user - The user that'll be using the connection to run SQL
  queries. The user is unprivileged, i.e. not a Postgres superuser.

* superuser - The privileded database user used to setup environment,
  define keys, etc. Exempt from many checks.

* secret key - The secret part of the public/private keypair. Known only
  to the superuser.

* public key - The public part of the keypair. Known to anyone, but
  only the superuser can set it for the instance/database/role.

* context - The list of key/value pairs, signed by the secret key.
  Only superuser can sign contexts, anyone can verify the signature.

The security relies on these restrictions, and failures render the
scheme insecure. See the following section listing some of the risks.

Another way to look at this is what actions need to happen:

* context signing - signing a context with the secret key

* public key setup - setting the public key for a given connection

* context setup - setting the GUC, with signature verification

* context reset - discarding the context

The components resposible for these actions depend on the architecture.
Let's briefly discuss two common cases. First without a connection pool,
and with a connection pool.

It's reasonable to assume the connection user is malicious - either
intentionally or by accident (e.g. by SQL injection). Otherwise why
bother with any of this?


### without a connection pool

In this architecture the application obtains direct connections to the
database, so the actions have to be performed by either the database or
the application itself. The question is how trusted the application is.

If the application is trusted, it can handle everything. It can install
the public key, either through a security definer function, or even by
connecting as superuser and switching to a different role.

This **requires** that the user not have access to the connection (and
can't run arbitrary SQL). This involves an assumption that there are no
SQL injection vulnerabilities.

If the application is untrusted, some of the steps have to be handled
by the database. In particular, the database needs to setup the public
key in a controlled way, so that the user can't pick an arbitrary one.
This also **requires** the user does not connect as a superuser.

The application will still install the signed context, but it needs to
be careful not to leak the signed values. The context acts as passwords,
and knowing a context is sufficient for impersonation (assuming both
are signed by the same key).


### with a connection pool

With a connection pool (which may include other types of middleware),
some of the steps can happen on the connection pool.

We assume the connection pool is more trusted than the application.
Otherwise the connection pool could be considered a component of the
application, and it'd be the same as the preceding section.

If the connection pool is more trusted, the more steps we can move to
the pool the better. It'd be possible for the pool to setup everything,
before handing the connection to the user:

* The public key could be set by the pool, unless already done by the
  database.

* The context can be looked up elsewhere (e.g. using `auth_query` in
  [PgBouncer](https://www.pgbouncer.org)) or even constructed on the
  connection pool itself. This could also be offloaded to some sort of
  trusted HSM component.

In this case none of the steps would be performed by the application,
greatly reducing the attack surface. The responsibilities are moved to
the connection pool, which is safer as the users don't have access to
that and can't run arbitrary SQL on it.


## Risks

Here's an overview of risks that could make the context insecure.

### leaking contexts

The signed context serves similar purpose as a password, but it has
a more complex internal structure. This means that if a signed context
leaks (e.g. to the server log), it may be used by someone else.

There are restrictions, e.g. the context can be used only in sessions
with the same public key (otherwise signature verification fails). And
a couple additional protections/mitigations could be added.

Nevertheless, it's probably better to (a) treat signed contexts just
like passwords, and (b) use the architecture where contexts are managed
by a separate component and not by the application.


### superusers

If the user is defined as a superuser role, it's trivial to change the
public key to a key picked by the user. The user then can construct and
sign arbitrary contexts, completely evading the protections.

Moreover, superusers bypass the RLS system entirely, so if the signed
context was used for that, it would matter anyway.


### C code

The public key and signed context are stored in memory. If the user can
gain access to that (through loading a custom C extension or some sort
of vulnerability), he could modify those two values.

But with this kind of access to memory, the user could do anything to
the server. The fact that it breaks the signed context is a detail.


## Possible improvements

There's a couple improvements I could think of while working on this.
Some of this would help addressing some of the risks above (perhaps not
entirely, but would reduce the risk).

### expiration

The context could include some sort of expiration, so that a leaked
context is not valid forever. A simple timestamp added to the beginning
of the context would do. It's not clear if it'd be verified only when
setting the context (after which the context remains valid forever), or
even when accessing the context later (automated sign-out).

Could work nicely in architectures where the signed context are issued
in an automated way, on request from a trusted component.


### set-once contexts

The context could be made settable only once, i.e. once it's set for a
session, it can't be altered. Seems to be incompatible with connection
pooling, unfortunately. But maybe it'd work if a requires the reset to
be authorized in some way (e.g. by extra password/superuser).


### additional information

The context could include additional metadata, e.g. IP address/port or
connection timestamp, binding it to a particular connection. This would
make it harder to use a leaked context. But it also requires some sort
of automated context signing, because the contexts will be unique for
connection.


### set key using security-definer function

If the key needs to be managed by the (trusted) application on a
per-session level, that requires superuser privileges. The connection
user however must not be a superuser, as that would break the scheme.

The best approach seems to be to install the key from a security-definer
function, ideally in a way that does not get the key as an argument,
but determines it e.g. by lookup (based on session information the user
can't alter - role/database/IP/timestamp/...).


### logon trigger to assign the key?

Postgres now has ["login" event trigger](https://www.postgresql.org/docs/17/event-trigger-database-login-example.html)
(since version 17). This seems it might be quite useful for establishing
the context, in a way the user can't interfere with easily.

Probably incompatible with connection pooling, as the trigger runs only
once, but the connection is kept and reused (for different users).


### easier key rotation

Right now each session has a single public key defined, and there's no
way to rotate the keys. The key can be changed easily, and already set
contexts remain valid, but new connections have to use the new key.

It would be possible to support multiple public keys, and some sort of
overlapping validity, for gradual transition to contexts signed by the
new key pair.


## Similar constructs

This is not a new idea, it resembles various other widely used concepts.
Here's a short list of similar solutions that I can think of.


### signed cookies

A HTTP cookie (possibly with internal structure), signed to protect the
cookie against modifications by the user. This is pretty much exactly
what the signed_context does.

For example django [signs cookies](https://docs.djangoproject.com/en/5.2/topics/signing/)
does this, although the signature is done differently - it's based on
symmetric cryptography (`sha256`).


### JWT ([JSON Web Tokens](https://en.wikipedia.org/wiki/JSON_Web_Token))

Is a more formal specification (proposed standard) of a JSON payload,
signed with a private or public/private key. It encodes "claims", which
are declarations about the identity of the user.

This is very close to what signed_context does. It also makes (or can
make) claims about the identity of the user (e.g. `TENANT_ID` is such
a claim). It does use a simpler key/value format, but that's a detail.
Other than that it's very close.

Perhaps JWT would be a better foundation for signed_context?


## Installation

Installing this is very simple, especially if you're using pgxn client.
All you need to do is this:

    $ pgxn install signed_context
    $ pgxn load -d mydb signed_context

and you're done. You may also install the extension manually:

    $ make install
    $ psql dbname -c "CREATE EXTENSION signed_context"

And if you're on an older version (pre-9.1), you have to run the SQL
script manually

    $ psql dbname < `pg_config --sharedir`/contrib/signed_context--1.0.0.sql

That's all. You'll need to define the public key next.


## License

This software is distributed under the terms of BSD 2-clause license.
See LICENSE or http://www.opensource.org/licenses/bsd-license.php for
more details.
